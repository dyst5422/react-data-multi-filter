{"version":3,"sources":["../src/DataFilter.tsx"],"names":[],"mappings":"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","file":"DataFilter.js","sourcesContent":["import * as React from 'react';\nimport memoize from 'memoizee';\n\nexport interface DataFilterProps<T> {\n  data: T[];\n  // tslint:disable-next-line:no-any\n  filters?: { [key: string]: { (datum: T, idx?: number, data?: T[]): boolean; [key: string]: any } };\n  children: (\n    props: {\n      filteredInData: T[];\n      filteredOutData: T[];\n      allData: T[];\n      // tslint:disable-next-line:no-any\n      filters: { [key: string]: { (datum: T, idx?: number, data?: T[]): boolean; [key: string]: any } };\n      // tslint:disable-next-line:no-any\n      activeFilters: { [key: string]: { (datum: T, idx?: number, data?: T[]): boolean; [key: string]: any } };\n      addFilters: (filters: { [key: string]: (datum: T, idx?: number, data?: T[]) => boolean }) => void;\n      removeFilters: (removeKeys: string[]) => void;\n      filterData: (\n        opts?: { exclude?: string[]; include?: string[] },\n      ) => {\n        filteredInData: T[];\n        filteredOutData: T[];\n        // tslint:disable-next-line:no-any\n        activeFilters: { [key: string]: { (datum: T, idx?: number, data?: T[]): boolean; [key: string]: any } };\n      };\n    },\n  ) => JSX.Element;\n}\n\nexport interface DataFilterState<T> {\n  filters: { [key: string]: (datum: T, idx?: number, data?: T[]) => boolean };\n}\n\n// tslint:disable-next-line:max-line-length\nexport class DataFilter<T> extends React.Component<DataFilterProps<T>, DataFilterState<T>> {\n\n  private applyFilterToData = memoize((data: T[], filter: (datum: T, idx?: number, data?: T[]) => boolean) => {\n    const filterResults: boolean[] = [];\n    for (let idx = 0; idx < data.length; idx += 1) {\n      if (filter(data[idx], idx, data)) {\n        filterResults.push(true);\n      } else {\n        filterResults.push(false);\n      }\n    }\n    return filterResults;\n  });\n\n  private memoizedFilterData = memoize((\n    data: T[],\n    // tslint:disable-next-line:no-any\n    filters: { [key: string]: { (datum: T, idx?: number, data?: T[]): boolean; [key: string]: any } },\n    exclude: string[],\n    include?: string[],\n  ) => {\n    let filtersKeysToInclude = Object.keys(filters);\n\n    if (include) {\n      filtersKeysToInclude = include;\n    }\n\n    filtersKeysToInclude = filtersKeysToInclude.filter(filterKey => !exclude!.includes(filterKey));\n\n    const filteredOutData: T[] = [];\n    const filteredInData: T[] = [];\n\n    const filterResults: { [key: string]: boolean[] } = {};\n    for (const filterKey of filtersKeysToInclude) {\n      filterResults[filterKey] = this.applyFilterToData(data, filters[filterKey]);\n    }\n\n    dataLoop: for (let idx = 0; idx < data.length; idx += 1) {\n      for (const filterKey of Object.keys(filterResults)) {\n        if (filters[filterKey]) {\n          if (!filterResults[filterKey][idx]) {\n            filteredOutData.push(data[idx]);\n            continue dataLoop;\n          }\n        }\n      }\n      filteredInData.push(data[idx]);\n    }\n\n    return {\n      filteredOutData,\n      filteredInData,\n      activeFilters: filtersKeysToInclude.reduce(\n        (accumulator, filterKey) => ({\n          ...accumulator,\n          [filterKey]: filters[filterKey],\n        }),\n        // tslint:disable-next-line:no-any\n        {} as { [key: string]: { (datum: T, idx?: number, data?: T[]): boolean; [key: string]: any } },\n      ),\n    };\n  });\n\n  private static memoizeHashOfFuncs<F extends Function>(funcHash: { [key: string]: F }) {\n    return Object.keys(funcHash).reduce(\n      (accumulator, key) => {\n        const memoizedFunc = memoize(funcHash[key], { length: funcHash[key].length });\n        // Assign any properties to the new memoized function\n        for (const propertyKey of Object.keys(funcHash[key])) {\n          memoizedFunc[propertyKey] = funcHash[key][propertyKey];\n        }\n        return {\n          ...accumulator,\n          [key]: memoizedFunc,\n        };\n      },\n      {} as { [key: string]: F },\n    );\n  }\n\n  constructor(props: DataFilterProps<T>) {\n    super(props);\n    let filters: { [key: string]: (datum: T, idx?: number, data?: T[]) => boolean } = {};\n    if (props.filters) {\n      filters = DataFilter.memoizeHashOfFuncs(props.filters);\n    }\n\n    this.state = {\n      filters,\n    };\n  }\n\n  public render() {\n    const { filteredInData, filteredOutData, activeFilters } = this.filterData();\n    return this.props.children({\n      allData: this.props.data,\n      filteredInData,\n      filteredOutData,\n      filters: this.state.filters,\n      activeFilters,\n      addFilters: this.addFilters,\n      removeFilters: this.removeFilters,\n      filterData: this.filterData,\n    });\n  }\n\n  private filterData = (opts?: { include?: string[]; exclude?: string[] }) =>\n    this.memoizedFilterData(\n      this.props.data,\n      this.state.filters,\n      (opts && opts.exclude) || [],\n      (opts && opts.include) || undefined,\n    )\n\n  private addFilters = (filters: {\n    // tslint:disable-next-line:no-any\n    [key: string]: { (datum: T, idx?: number, data?: T[]): boolean; [key: string]: any };\n  }) => {\n    this.setState({\n      filters: {\n        ...this.state.filters,\n        ...DataFilter.memoizeHashOfFuncs(filters),\n      },\n    });\n  }\n\n  private removeFilters = (removeKeys: string[]) => {\n    const filters = Object.keys(this.state.filters).reduce(\n      (accumulator, filterKey) => {\n        if (removeKeys.includes(filterKey)) {\n          return accumulator;\n        } else {\n          return {\n            ...accumulator,\n            [filterKey]: this.state.filters[filterKey],\n          };\n        }\n      },\n      {} as { [key: string]: (datum: T, idx?: number, data?: T[]) => boolean },\n    );\n    this.setState({\n      filters,\n    });\n  }\n}"]}